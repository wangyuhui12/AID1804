

python　如何进行内存管理：
    １、引用计数机制
    ２、垃圾回收机制
    ３、内存池机制


引用计数机制：
　python程序中使用的每个变量后台都有一个引用计数。赋值或调用操作，计数加一；相反，删除或移出窗口对象计数减一。

a = 1　　
　　１　就是对象，a 就是引用，　引用a指向对象１
b = 1
    b 也是对象。　　id(a)  返回的是对象的地址

为了检验两个引用指向同一个对象，我们可以用is关键字。is用于判断两个引用所指向的对象是否相同。
在python中，整数和短小的字符，python都会缓存这些对象，以便重复使用。赋值语句，只是创造了新的引用，而不是对象本身。长的字符串和其它对象可以有多个相同的对象，可以使用赋值语句创建出新的对象。每个对象都有存有指向该对象的引用总数，即引用计数(reference count)。
可以使用sys.getrefcount()获得引用计数，需要注意的是，当使用某个引用作为参数，传递给getrefcount()时，参数实际上创建了一个临时的引用。因此，getrefcount()所得到的结果，会比期望的结果多１。

引用计数增加：
    １、对象被创建
    ２、另外的别人别创建：　y=x
    ３、被作为参数传递给函数：foo(x)
    ４、作为容器对象的一个元素：a=[1, x, '33']

引用计数减少：
    １、一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x 指向的对象引用减１．
    ２、对象的别名被显式的销毁：del x;或者del y
    ３、对象的一个别名被赋值给其他对象: x=789
    ４、对象从一个窗口对象中移除：　myList.remove(x)
    ５、窗口对象本身被销毁： del myList,或者窗口对象本身离开了作用域。

垃圾收集：
　将引用计数为０的对象所占有的内存空间释放。还有一个循环垃圾收集器，负责清理未引用的循环，如两个对象互相引用的情况。

    引用计数（对循环引用不适用）　　　标记清除　　　分代回收

如果出现循环引用的话，引用计数机制就不再起有效作用了。

循环引用可以使一组对象的引用计数不为０，然而这些对象实际上并没有被任何外部对象所引用，它们之间只是相互引用。这意味着不会再有人使用这组对象，应该回收这组对象所占用的内存的空间，然后由于相互引用的存在，每一个对象的引用计数都不为０，因此这些对象所占用的内存永远不会被释放。

内存池：
　用于管理对小块内存的申请和释放。２５６字节为界限。(可通过源代码更改)
　内存池是预先从内存中申请的内存块，当创建小于256bits的对象时，从内存池申请内存空间。创建大于２５６bits的对象从内存申请空间。释放内存时，来自内存池的内存空间返回给内存池。这样做的目的是为了减少内存碎片，提升效率。




day12 回顾：

__doc__　属性
    用来绑定文档字符串

__name__属性
    用来绑定函数的名字

模块 module

模块的分类：
    内建模块
        builtins
    标准库模块：
        .py
    第三方模块：


模块的导入语句：
import 语句
from   import 语句
from   import * 语句

属性：某个模块的变量


dir()  函数
    变量全部属性的列表
    返回当前作用域的全部变量名的列表
    模块的变量名列表
    对象的变量名列表

math 模块

time 模块
time.time()
time.sleep(n)
time.gmtime(s)  将utc秒数返回utc时间元组
time.mktime(time)  返回秒数utc
time.localtime(s) 返回日期元组

day13　笔记

sys 模块

sys.path    
    模块搜索路径;path[0]是当前脚本程序的路径名，否则为""
sys.modules 
    已加载模块的字典
sys.version
    版本信息字符串
sys.version_info
    版本信息的命名元组
sys.platform
    操作系统平台名称信息
sys.argv
    命令行参数argv[0]代表当前脚本程序路径名
    绑定用户启动程序时命令行参数的列表
sys.copyright
    获得python版权相关的信息
sys.builtin_module_names
    获得python内建模块的名称（字符串元组）

标准输入输出时会用到
sys.stdin
    标准输入文件对象，多用于input()
sys.stdout
    标准输出文件对象，多用于input()
sys.stderr
    标准错误输出文件对象，用于输出错误信息

sys.exit([arg])
    退出程序，正常退出时sys.exit(0)
sys.getrecursionlimit()
    得到递归层次限制（栈的深度）
sys.setrecursionlimit(n)
    得到和修改递归嵌套层次限制（栈的深度）

>>> sys.version_info
sys.version_info(major=3, minor=5, micro=2, releaselevel='final', serial=0)
>>> sys.version_info.releaselevel
'final'


自定义模块的模块名必须符合"标识符"的命名规则(同变量名)

模块有各自独立的作用域
    示例见：
        mymod2.py
        mymod1.py
        06_test_mymod.py

模块化编程的优点：
　１、有利于多人合作开发
　２、提高代码的复用率
　３、有利于解决变量名冲突问题
　４、使代码更易于维护

import　语句　搜索模块的路径顺序
　１、搜索程序运行时的路径（当前路径）
　２、sys.path提供的路径
　３、搜索内置模块

sys.path 是一个存储模块搜索路径的列表
　１、可以把自定义的模块放在相应的路径下可以导入
　２、可以把自己模块的路径添加在sys.path列表中

示例：
import sys
sys.path.append('/home/tarena')

模块的加载过程：
　１、在模块导入时，模块的所有语句会执行
　２、如果一个模块已经导入，则再次导入时不会重新执行模块内的语句

模块的重新加载：
import mymod3
import imp
imp.reload(mymod3)   # 重新加载mymod3模块

模块被导入和执行的过程：
　１、先搜索相关的路径找模块(.py)
　２、判断是否有此模块对应的.pyc文件，如果存在pyc文件且比.py新，则直接加载.pyc文件
　３、否则用.py文件生成.pyc后再进行加载
　

pyc 模块的编译文件
            编译              解释执行
　　mymod1.py ---->　mymod1.pyc --------->　python3

模块的属性
 属性实质是变量（是模块内的全局变量）

模块内预制的属性
　__doc__ 属性
    作用：
        用来绑定模块的文档字符串

模块内第一个没有赋值给任何变量的字符串为模块的文档字符串


__file__ 属性
　__file__　绑定模块对应的文档路径名
    １、对于内建模块，不绑定路径（没有__file__属性）
    ２、对于其它模块，绑定路径名的字符串

__name__　属性
　此属性用来记录模块的自身名字
作用：
　１、记录模块名
　２、用来判断是否为主模块（最先进行的模块）
说明：
　当此模块为主模块时，　__name__绑定"__main__"
　当此模块不是主模块时，此属性绑定模块名

模块的__all__列表
　模块中的__all__列表是一个用来存放可导出属性的字符串列表
作用：
　当用from import * 语句导入时，　只导入__all__列表内的属性
示例见：
    mymod6.py

模块的隐藏属性
　模块中以'_'开头的属性，在from import *语句导入时，将不被导入，通常称这些属性为隐藏属性

示例见：
　mymod7.py

随机模块　random
 作用：
    用于模拟或生成随机输出的模块

import random as R

R.random()   返回一个[0,1]之间的随机数
R.uniform()  返回[a, b]区间内的随机实数
R.randrange([start,] stop[,step])
    返回range(start, stop, step)的随机数
R.choice(seq)  从序列中返回随意元素
R.sample(seq,n) 从序列中选择n个随机且不重复的元素

练习：
　猜数字游戏：
    写程序，随机生成一个０～１００之间的数用变量x绑定循环让用户输入一个数y，
    输出猜数字的结果
        如果y等于生成的数x，则提示”你猜对了“，打印出猜测的次数并退出
        如果y小于x则提示”您猜小了

包　（模块包） package
　包是将模块以文件夹的组织形式进行分组管理的方法

作用：
    将一系列模块进行分类管理，有利于防止命名冲突
    可以在需要时加载一个或部分模块而不是全部模块
包示例：
    mypack/
        __init__.py
        menu.py
        games/
            __init__.py
            contra.py
            supermario.py
            tanks.py
        office/
            __init__.py
            excel.py
            word.py

__init__.py文件
　１、常规包中必须存在的文件
__init__.py会在包加载时被自动调用

作用
　１、编写此包的内容
　２、在内部填写文档字符串
　３、在__init__.py内可以加载此包所依赖的一些其它模块

包　的导入：
　用三条import语句可以导入包（同模块的导入规则）

import 包名　[as 包别名]
import 包名.模块名　[as 模块新名]
import 包名.子包名.模块名

from　包名 import 模块名 [as 模块新名]
from 包名.子包名　import 模块名 [as 模块新名]
from 包名.子包名.模块名　import 属性名　[as 属性新名]

from 包名 import *
from 包名.模块名 import *
...

练习：
模拟斗地主发牌，牌共５４张，
黑桃('\u2660')
梅花('\u2663')
方块('\u2665')
黑桃('\u2666')
大小王
A2-10JQK
三个人玩，每个人发１７张牌，底牌留三张
操作：
    输入回车：打印第一个人的１７张牌
    输入回车：打印第二个人的１７张牌
    输入回车：打印第三个人的１７张牌
    输入回车：打印三张底牌