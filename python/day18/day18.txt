
初始化方法
def __init__(self, ...):
    语句块

析构方法：
def __del__(self):
    语句块

析构函数：
    类名（实参列表）
    作用：创建此类型的对象

实例的预置属性：
　__dict__
    用来绑定对象的属性的字典
 __class__
    用来绑定创建子集的类

用于判断类的函数：
    instance(obj, 类名或类名的元组)
    type(obj) 返回对象的类

 day18 变量：

类变量 class variable(也加类属性)
 类变量是类的属性，此属性属于类

作用：
　用来记录类相关的数据

说明：
　类变量可以通过类直接访问
　类变量可以通过类的实例直接访问
　类变量可以通过此类的实例的__class__　属性间接访问
示例：
class Human():
    count = 0  　# 创建类变量

print(Human.count)      # 0
Human.count = 100
print(Human.count)   # 100

类的文档字符串：
　类内第一个没有赋值给任何变量的字符串是类的文档字符串

说明：
    类的文档字符串用类的__doc__属性可以访问
    类的文档字符串可以用help()函数查看

类的 __slots__ 列表
　作用：
    限定一个类的实例只能有固定的属性（实例变量）
    通常为防止错写属性名而发生时错误

  说明：
    含有__slots__列表的类创建的实例对象没有__dict__属性，即此实例不用字典来保存对象的属性（实例变量）

__all__列表是一个用来存放可导出属性的字符串列表（模块）
作用：
　当用from import * 语句导入时，　只导入__all__列表内的属性

类方法　@classmethod
 类方法是描述类的行为的方法，类方法属于类

说明：
　类方法需要用@classmethod 装饰器定义
  类方法至少有一个形参，第一个形参用于绑定类，约定写为'cls'
  类和该类的实例都可以调用类方法
  类方法不能访问此类创建的实例的属性（只能访问类变量）

示例见：
　05_classmethod.py

问题：
    １、类方法属于类
    ２、实例方法属于该类的实例
    ３、请问：类内能不能有函数，这个函数不属于类，也不属于实例

 静态方法　@staticmethod
 　静态方法不属于类，也不属于类的实例，它相当于定义在类内普通函数，只是它的作用域属于类

练习：
 １、用类来描述一个学生的信息（可以用修改之前写的Student类）
 class Student():
    #　此处自己实现
   要求该类的对象用于存储学生信息：
    姓名、年龄、成绩
   将这些对象存于列表中，可以任意添加和删除学生信息
    １、打印出学生的个数
    ２、打印出所有学生的平均成绩
    （建议用类变量存储学生的个数，也可以把列表当做类变量）


继承　inheritance 和　派生 derived
什么是继承/派生
　１、继承是指从已有的类中衍生出新类，新类具有原类的行为并能扩展新的行为
  ２、派生就是从一个已有类中衍生(创建)新类，在新类上可以添加新的属性和行为

继承和派生的目的：
    继承是延续旧类的功能
    派生是为了在旧类的基础上添加新的功能

作用：
　１、用继承派生机制，可以将一些共有功能加在基类中，实现代码的共享
　２、在不改变基类的基础上改变原有功能

继承/派生的名词
　基类(base class), 超类(super class), 父类(father class)
  派生类(derived class) / 子类(child class)

单继承
　语法：
   class 类名(基类名):
    语句块
  说明：
  　单继承是指派生类由一个基类衍生出来的类

继承说明：
　任何类都直接或间接的继承自object类
　object类是一切类的超类(祖类)

类的__base__属性
　__base__属性用来记录此类的基类

覆盖　override
 什么是覆盖
 　覆盖是指在有继承关系的类中，子类中实现了与基类同名的方法，在子类实例调用该方法时，实例调用的是子类中的覆盖版本的方法，这种现象叫覆盖


super 函数
　super(type, obj) 返回绑定超类的实例
  super()  返回绑定超类的实例，等同于：
        super(__class__, 实例方法的第一个参数)
        (必须在方法内调用)

显示调用基类的初始化方法：
　当子类中实现了 __init__　方法时，　基类的__init__方法并不会被自动调用，此时需要显式调用

示例见：
    13_super.py



预告：
    封装
    多态
    多继承
    运算符重
    with语句


１、看懂学生管理系统的类的封装的代码

２、写一个类Bicycle(自行车)类，有run方法，调用时显示骑行里程km
class Bicycle:
    def run(self, km):
        print("自行车骑行了", km, "公里")


再写一个类EBicycle(电动自行车)类，在Bicycle类的基础上添加电池电量volume属性，有两个方法：
　１、file_charge(self, vol)　用来充电，　vol为电量
　２、run(km) 方法每骑行10km消耗电量1度，同时显示当前电量，则调用Bicycle的run方法骑行
class EBicycle(Bicycle):
    ...

b = Bicycle()
b.run(10)  # 自行车骑行了10公里
e = EBicycle(5)
e.run(10)   # 电动车骑行了１０公里
e.run(100)　＃电动车骑行了４０公里，自行侧骑行了６０公里
b.fill_charge(10)
b.run(100)













