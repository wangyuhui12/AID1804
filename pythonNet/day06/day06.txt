
进程对象属性
p.join()        回收进程
p.start()       启动进程
p.is_alive()    判断进程是否在alive　状态，在生命周期中返回TRUE 否则返回FALSE  

属性
p.name          进程名称 默认为Process-1 ..如果起名字则为自己取的名称　　
p.pid           进程的PID号

p.daemon
默认为False　主进程退出不会影响子进程
如果设置为True　则主进程退出时会让所有子进程都退出

*　该属性的设置必须在　start()　前
*　该属性一般不用和join同时出现

创建自定义进程

１、继承Process类
２、运行Process类的　__init__　以获取父类属性
３、重写run方法，在通过自定义类生成对象后，调用start()　会自动执行这个方法

多进程
优点：　
    并行执行多个任务，　提高效率
    创建方便
    运行独立，不受其他进程影响
    数据安全

缺点：在进程的创建和删除过程中消耗计算机资源较多


进程池技术

产生原因：　如果有大量的任务，需要多进程完成，则可能需要频繁的创建和删除进程，　给计算机带来较多的消耗。

使用：　大量可以短时间完成的任务需要多进程操作的时候比较适用于进程池

使用方法：
１、创建进程池，在池内放入适当的进程
２、将事件加入进程池队列
３、事件不断运行，直到所有事件运行完成
４、关闭进程池，回收进程

from multiprocessing imort Pool

Pool(processes)
功能：　创建进程池对象
参数：　processes 表示进程池中有多少进程
对象：　进程池对象

pool.apply_async(func, args, kwds)
功能：　将事件放入进程池等待执行
参数：　
    func    要放入进程池的事件函数
    args    给func函数以元组传参
    kwds    给func函数以字典传参
返回值：　返回一个事件对象　通过get()方法可以获取事件函数的返回值

pool.close()
功能 :　关闭进程池　不能再添加新的事件

p.join()
功能：　回收进程池

pool.apply(func, args, kwds)
功能：　将事件放入进程池等待执行
参数：　
    func    要放入进程池的事件函数
    args    给func函数以元组传参
    kwds    给func函数以字典传参

pool.map(func, iter)
功能：　将要完成的事件放入到进程池
参数: 　func 要完成的事件函数
    　　iter 要给func传递的参数的迭代器
返回值：　返回事件函数的返回值列表

练习：
　使用multiprocessing　创建两个进程，分别复制一个文件的上半部分和下半部分到另一个新的文件中

cookie: os.path.getsize(path) 获取文件大小

进程间通信

进程间通信由于空间独立，资源互相无法直接获取，此时在不同的进程间传递数据就需要专门的进程间通信方法

和磁盘交互： 使用中间文件， 但是不安全， 速度慢

进程间通信的方法 (IPC)
  管道  消息队列    共享内存    信号  信号量    套接字


管道通信 Pipe

在内存中开辟一块空间， 形成管道结构，管道对多个进程可见， 进程可以通过对管道的读写操作进行通信。

multiprocessing ---> Pipe 

fd1, fd2 = Pipe(duplex = True)
功能： 创建一个管道
参数： 默认表示管道为双向管道
      如果设置为False 则表示单向管道

返回值： 返回两个管道流对象，表示管道两端
        如果是双向管道，则都可以读写
        如果是单向管道，则fd1只读，fd2只写

fd1.recv()
功能 ： 从管道内读信息
返回值： 读到的内容

* 当管道内无内容的时候会阻塞

fd2.send(data)
功能： 向管道写入内容
参数： 要写的内容

* 可以发送几乎python的任意数据类型


消息队列

队列：先进先出
在内存中开辟队列结构空间，　对多个进程可见。多个进程向队列中存入消息，取出消息，完成进程间通信。

创建队列　
q = Queue(maxsize = 0)
功能：　创建队列
参数：maxsize　默认表示根据系统分配空间存储消息
    如果传入一个正整数则表示最多存入消息数量
返回值：　队列对象

q.put(data, [block, timeout])
功能 : 向队列中存入消息
参数　: data   存入的数据　(支持python 数据类型)
    　　block  默认为True表示阻塞　当队列满时阻塞
            　设置为False　表示非阻塞
    　　timeout  当block为True时表示超时时间　　　

data = q.get([block, timeout])
功能　：　从队列获取消息
参数　：　block  默认为True表示阻塞　当队列空时阻塞
　　　　　　　设置为False　表示非阻塞
    　　timeout  当block为True时表示超时时间　　
返回值：　返回获取到的消息

q.full()    判断队列是否为满
q.empty()　　　判断队列是否为空
q.qsize()   获取队列中消息数量
q.close()   关闭队列

共享内存

在内存中开辟一段空间，存储数据，对多个进程可见。
每次写入共享内存的数据会覆盖之前的内容

from multiprocessing import Value, Array

obj = Value(ctype, obj)
功能：　开辟共享内存空间
参数：ctype    字符串  要转变的c的类型code　（对照ctype表）

    　obj    共享内存初始值

返回值：　返回共享内存对象    

obj.value   表示共享内存中的值。对其修改或者使用即为使用共享内存中的值 

obj = Array(ctype, obj)
功能：　开辟共享内存空间
参数：　ctype 要转换的类型
    　　obj　　要存入共享内存的数据
        　　列表　　将列表存入共享内存　要求类型一致
        　　整数　　在共享内存中开辟几个单元的空间
返回值：　返回共享内存对象


        　　　　管道　        消息队列　        共享内存
从开辟空间　　　　内存       　　内存　　　　　        内存

读写方式　　　　　两端读写　　　　　　先进先出　　　　　　　操作覆盖内存
        　　　双向/单向　　　　　

效率        一般　　　　　　　　　　一般　　　　　　　　　　　　　较快

应用　　  多用于父子进程　　　　广泛灵活　　　　　　复杂，　需要互斥机制



作业：
    熟练掌握进程间通信方法
    自己实现进程池的使用，　知道进程池的特性
    文件操作